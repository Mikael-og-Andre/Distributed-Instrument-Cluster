@layout NothingLayout
@using System.Net.WebSockets
@using System.Runtime.CompilerServices
@using System.Text
@using System.Text.Json
@using System.Threading
@using Blazor_Instrument_Cluster.Shared
@using PackageClasses
@inject IJSRuntime JS
@inject NavigationManager navigationManager

<div class="container">
    <div class="row">
        <div class="col">
            <button class="btn btn-dark">
                <input id="canvas"
                       style="width: 100%; height: 100%; border: 1px solid black; position: absolute; top: 0; left: 0; z-index: 100; opacity: 0; cursor: pointer"
                       @onclick="click"
                       @onmousemove="move"
                       @onmousedown="mouseDown"
                       @onmouseup="mouseUp"
                       @onkeydown="keyDown"
                       @onkeyup="keyUp" />
                Lock Mouse
            </button>
        </div>
        <div class="col">
            <button @onclick="connectToCrestronControl" class="btn btn-dark">
                Connect
            </button>
        </div>
        <div class="col">
            @if (deviceAndControllerFound&&(!controlling)) {
                <p><b>Status:</b> In queue, Position: @queuePosition</p>
            }
            else if (deviceAndControllerFound&&controlling) {
                <p><b>Status:</b> Controlling</p>
            }
            else {
                <p><b>Status:</b> Not Connected</p>
            }
        </div>
    </div>
</div>

@code {
    /// <summary>
    /// Handles capturing pointer lock data, key events and sends it to a web socket.
    /// </summary>
    /// <author>Andre Helland, Mikael Nilssen</author>
    private CancellationTokenSource disposalTokenSource = new CancellationTokenSource();    //Disposal token used in websocket communication

    private ClientWebSocket crestronWebSocket = null;                                       //Websocket client

    [Parameter]
    public string name { get; set; }                                        //Name of the wanted device
    [Parameter]
    public string location { get; set; }
    [Parameter]
    public string type { get; set; }
    [Parameter]
    public string subname { get; set; }

    private bool deviceAndControllerFound = false;                                               //Bool representing if the control of the device has been granted
    private bool controlling = false;

    [CascadingParameter]
    public int queuePosition { get; set; } = -1;

    private string pathToCrestronWebsocket = "crestronControl";

    #region Events

    private async void click(MouseEventArgs e) {
        await JS.InvokeVoidAsync("click");
    }

    private void mouseDown(MouseEventArgs e) {
        Console.WriteLine(e.Button);
        sendData("mouseClick (" + e.Button + ",1)");    // 1=make/down.
    }

    private void mouseUp(MouseEventArgs e) {
        Console.WriteLine(e.Button);
        sendData("mouseClick (" + e.Button + ",0)");    // 0=break/up.
    }

    private void keyDown(KeyboardEventArgs e) {
        Console.WriteLine(e.Code);
        Console.WriteLine(e.Key);
        switch (e.Code) {
            case "Space":
                if (downedKeys.ContainsKey(e.Code)) break;
                sendData("make space");
                downedKeys.Add(e.Code, true);
                return;
            case "Tab":
                return;
            default:
                if (downedKeys.ContainsKey(e.Code)) break;
                sendData("make " + e.Key);
                downedKeys.Add(e.Code, true);
                break;
        }
    }

    private Dictionary<string, bool> downedKeys = new();

    private void keyUp(KeyboardEventArgs e) {
        Console.WriteLine(e.Code);
        switch (e.Code) {
            case "Space":
                sendData("break space");
                downedKeys.Remove(e.Code);
                return;
            case "Tab":
                return;
            default:
                sendData("break " + e.Key);
                downedKeys.Remove(e.Code);
                break;
        }
    }

    //TODO: FIX
    private void scroll() {
        Console.WriteLine("ok?");
        //Console.WriteLine(e.Detail);
    }

    private async void move(MouseEventArgs e) {
        int[] deltas = await JS.InvokeAsync<int[]>("getPositionChange");

        int x = deltas[0];
        int y = deltas[1];

        sendData("movecursor (" + x + "," + y + ")");
    }

    #endregion

    private async void sendData(string s) {
        if (!(await JS.InvokeAsync<bool>("isLocked"))) return;
        if (!deviceAndControllerFound) {
            Console.WriteLine("Device not found");
            return;
        }
        if (!controlling) {
            Console.WriteLine("Not controlling");
            return;
        }

        try {
            //Create object
            ExampleCrestronMsgObject sendingObject = new ExampleCrestronMsgObject(s);
            //Create json
            string json = JsonSerializer.Serialize(sendingObject);
            //Convert to bytes
            ArraySegment<byte> bytesToSend = new ArraySegment<byte>(Encoding.UTF8.GetBytes(json));

            //Send data to socket.
            await crestronWebSocket.SendAsync(bytesToSend, WebSocketMessageType.Text, true, disposalTokenSource.Token);
        }
        catch (Exception e) {
            Console.WriteLine(e.Message);
        }

    }

    //Run setup when DOM is loaded.
    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            await JS.InvokeVoidAsync("setup");
        }
    }

    #region socket

    /// <summary>
    /// Connect to the backend device
    /// </summary>
    /// <returns></returns>
    private async Task connectToCrestronControl() {

        crestronWebSocket?.Abort();
        crestronWebSocket = new ClientWebSocket();

        //Get base uri and connect to that
        string basePath = navigationManager.BaseUri;
        basePath = basePath.Replace("https://", "wss://");

        await crestronWebSocket.ConnectAsync(new Uri(basePath + pathToCrestronWebsocket), disposalTokenSource.Token);
        //Check if the device requested exists
        try {
            deviceAndControllerFound = await SetupSocket();
            StateHasChanged();
            //enter the queue
            if (deviceAndControllerFound) {
                controlling = await enterQueue();
                StateHasChanged();
            }
        }
        catch (Exception) {
            Console.WriteLine("Connection failed");
        }

    }
    /// <summary>
    /// Does setup with backend websocket, sends name to server, and returns if it was found or not
    /// </summary>
    /// <returns></returns>
    private async Task<bool> SetupSocket() {
        try {
            //Receive start signal
            byte[] startBuffer = new byte[1024];
            ArraySegment<byte> startSignalBuffer = new ArraySegment<byte>(startBuffer);
            await crestronWebSocket.ReceiveAsync(startSignalBuffer, disposalTokenSource.Token);

            //Get json data for a RequestConnectionModel
            RequestConnectionModel requestModel = new RequestConnectionModel(name, location, type, subname);

            byte[] jsonBytes = JsonSerializer.SerializeToUtf8Bytes(requestModel);

            //Send device data
            await crestronWebSocket.SendAsync(jsonBytes, WebSocketMessageType.Text, true, disposalTokenSource.Token);

            //Get found or not
            byte[] foundBuffer = new byte[1024];
            ArraySegment<byte> foundBytes = new ArraySegment<byte>(foundBuffer);
            await crestronWebSocket.ReceiveAsync(foundBytes, disposalTokenSource.Token);
            string found = Encoding.UTF8.GetString(foundBytes).TrimEnd('\0');

            //Device was found
            if (found.ToLower().Equals("Found Device".ToLower())) {
                //Now wait to check if the controller gets found
                byte[] controllerFoundBuffer = new byte[1024];
                ArraySegment<byte> controllerFoundSeg = new ArraySegment<byte>(controllerFoundBuffer);
                await crestronWebSocket.ReceiveAsync(controllerFoundBuffer,disposalTokenSource.Token);
                string controllerFoundString = Encoding.UTF8.GetString(controllerFoundSeg).TrimEnd('\0');

                //Check if controller is found
                return controllerFoundString.ToLower().Equals("Found Controller".ToLower());
            }
            else {
                return false;
            }
            
        }
        catch (Exception) {
            Console.WriteLine("Error when requesting a device");
            return false;
        }

    }

    private async Task<bool> enterQueue() {
        try {

            //receive position in queue
            string receivedMsg = "";
            while (!disposalTokenSource.IsCancellationRequested) {
                //Receive a message
                byte[] queueBytes = new byte[1024];
                ArraySegment<byte> qSegment = new ArraySegment<byte>(queueBytes);
                await crestronWebSocket.ReceiveAsync(qSegment, disposalTokenSource.Token);
                receivedMsg = Encoding.UTF8.GetString(qSegment).TrimEnd('\0');
                //If msg is controlling break
                if (receivedMsg.ToLower().Equals("controlling".ToLower())) {
                    Console.WriteLine("Has control");
                    return true;
                }

                //try to cast queue position
                //Check if all chars in string is a number
                if (receivedMsg.All(char.IsDigit)) {
                    try {
                        int parsedInt = int.Parse(receivedMsg);
                        //Update position value
                        queuePosition = parsedInt;
                        //Log
                        Console.WriteLine("Queue position: " + queuePosition);
                        //Update state
                        StateHasChanged();
                    }
                    catch (Exception) {
                        Console.WriteLine("Failed to parse queue position {0}", receivedMsg);
                    }
                }
            }
            return false;
        }
        catch (Exception) {
            Console.WriteLine("Error occurred while in queue");
            return false;
        }
    }

    #endregion
}